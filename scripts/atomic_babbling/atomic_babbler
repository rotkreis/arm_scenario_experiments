#!/usr/bin/env python
""" This scripts control baxter so that it moves one joint at a time (hence atomic babbling)

It does not take care of recording itself directly but controls the recorder such that every movement is recorded in a separated bag file.
You choose which joint to move or not by giving a list after the argument --joints, or use --all.

Detailed description: the following process is repeated several times:
1/ a pose for the limb is randomly chosen, then,
2/ for each joint specified in the command line arguments,
    1. a call to the recorder/start service is made to start recording in a new bag
    2. the controller moves the joint from its minimum to its maximum position (modulo some margin).
    3. a call to /recorder/stop is done to stop recording and close the bag
"""

import math
import random
import argparse

import rospy

from tf import transformations as tft

np = tft.numpy

from std_msgs.msg import Empty
from std_srvs.srv import Trigger
from arm_scenario_experiments.srv import String as StringSrv
import baxter_interface
from baxter_interface import CHECK_VERSION
from arm_scenario_experiments import baxter_utils
import \
    arm_scenario_simulator.head_simulator_fix  # this is a patch to be able to control correctly the head in simulation. If not imported, the method Head.move_to_pan is not defined. Cf


def main(do_joints):
    babbler = Atomic_Babbler(do_joints)
    reset_env = rospy.Publisher('/environment/reset', Empty, queue_size=1)
    last_time = rospy.get_time()
    for k in range(100):
        if rospy.get_time() - last_time > 300:
            reset_env.publish(Empty())
            print("Reseting the environment")
            rospy.sleep(3)
            last_time = rospy.get_time()
        babbler.go_and_move()


class Atomic_Babbler(object):
    def __init__(self, do_joints):
        # Command Current Joint Positions first
        self.left_arm = baxter_interface.Limb('left')
        self.right_arm = baxter_interface.Limb('right')
        # self.babbling_arm = self.left_arm if side is 'left' else self.right_arm
        self.head = baxter_interface.Head()
        self.do_joints = do_joints
        self.init_ee_pos = baxter_utils.get_ee_position(self.left_arm)
        self.init_ee_orientation = baxter_utils.get_ee_orientation(self.left_arm)

        self.new_record_srv = rospy.ServiceProxy('/recorder/start', StringSrv)
        self.stop_record_srv = rospy.ServiceProxy('/recorder/stop', Trigger)
        self.counter = 0
        self.recorder = False
        try:
            self.new_record_srv.wait_for_service(timeout=2.0)
            print('A recorder has been found')
            self.recorder = True
        except:
            print('No recorder found')
            pass

    def start_recording(self, bagname):
        if self.recorder:
            self.new_record_srv.wait_for_service(timeout=1.0)
            self.new_record_srv(bagname)

    def stop_recording(self):
        if self.recorder:
            self.stop_record_srv.wait_for_service(timeout=1.0)
            self.stop_record_srv()

    def go_and_move(self):
        joint_angles = None
        while joint_angles is None:  # randomly select a 3D position for the end-effector (ee)
            position = self.init_ee_pos + np.random.uniform(-1, 1, 3) * np.array([0.25, 0.25, 0.15])
            orien = slight_d(self.init_ee_orientation, 0.2, 0.2)
            joint_angles = baxter_utils.IK(self.left_arm, position,
                                           orien)  # compute the joint_angles correspondingto the ee pose
        self.left_arm.move_to_joint_positions(joint_angles)
        self.counter += 1
        self.head.move_to_pan(random.uniform(-0.3, 0.3), speed=1.5, blocking=True)

        rospy.sleep(1)
        if 'head_pan' in self.do_joints: self.turn_head(speed=1.0, pause=0.3)
        jiggle_params = {'left_s0': {'normalized_targets': [-0.2, 0.2], 'speed': 0.4, 'pause': 0.3, 'margin': 0.2},
                         'left_s1': {'normalized_targets': [-0.1, 0.2], 'speed': 0.4, 'pause': 0.3, 'margin': 0.2},
                         'left_e0': {'normalized_targets': [-0.1, 0.1], 'speed': 0.4, 'pause': 0.3, 'margin': 0.2},
                         'left_e1': {'normalized_targets': [-0.2, 0.2], 'speed': 0.4, 'pause': 0.3, 'margin': 0.2}}
        for joint in self.do_joints:
            if joint in jiggle_params:
                self.jiggle(joint, jiggle_params[joint]['normalized_targets'], jiggle_params[joint]['speed'],
                            jiggle_params[joint]['pause'], jiggle_params[joint]['margin'])

    def turn_head(self, speed, pause):
        """ Makes the head turn right an left"""
        init_pan = self.head.pan()
        self.start_recording('pose{}_head_pan'.format(self.counter))
        self.head.move_to_pan(-0.8, speed=speed, blocking=True)
        rospy.sleep(pause)
        self.head.move_to_pan(0.8, speed=speed, blocking=True)
        rospy.sleep(pause)
        self.head.move_to_pan(init_pan, speed=speed, blocking=True)

        self.stop_recording()
        rospy.sleep(pause)

    def jiggle(self, joint_name, normalized_targets, speed, pause=0, margin=0):
        """ Make the joint move to the given targets at the given speed"""
        self.start_recording(('pose{}_' + joint_name).format(self.counter))
        init_pos = self.left_arm.joint_angles()[joint_name]
        prev_target = init_pos
        for nt in normalized_targets:
            target = init_pos + nt * magnitudes[joint_name]
            target = clip(target, joint_name, margin)
            move(self.left_arm, {joint_name: target}, length=abs(target - prev_target) / speed)
            prev_target = target
            rospy.sleep(pause)
        move(self.left_arm, {joint_name: init_pos}, length=abs(init_pos - prev_target) / speed)

        self.stop_recording()
        rospy.sleep(pause)


def move(limb, target_positions, length, uprate=100):
    """ Move linearly all the joints from their current position to the position specified in the target_positions dictionary
    The length of the movement has to be given. """
    length = max(0.5, length)
    rate = rospy.Rate(uprate)
    tstart = rospy.get_time()
    start_joints = limb.joint_angles()
    names = target_positions.keys()
    while not rospy.is_shutdown():
        t = rospy.get_time() - tstart
        if t > length: break
        targets = {name: target_positions[name] * t / length + (length - t) * start_joints[name] / length for name in
                   names}
        limb.set_joint_positions(targets)
        rate.sleep()


def slight_d(quat, stdvec, stda):
    """ Returns a quaternion consisting of a slight deviation of the input quaternion """
    # WARNING #  Unlike the famous transformations.py which denotes quaternions as arrays [w, x, y, z],
    # WARNING #  tf.transformations denotes quaternions as arrays [x, y, z, w], which is the case here !!!!!
    vec = tft.unit_vector(quat[:3])
    a = 2 * math.acos(quat[3]) + random.random() * stda
    vec += np.random.uniform(-1, 1, 3) * stdvec
    vec = math.sin(a / 2) * tft.unit_vector(vec)
    return np.concatenate((vec, [math.cos(a / 2)]))


def clip(x, name, margin_min=0, margin_max=None):
    """ Clip the joint_angle between the min_value and max_value (the valid interval) of this joint_angle
    margins (in [0,1]) can be provided to addtionally reduce the valid interval. Limits are augmented/reduced by margin*magnitude(joint). """
    margin_max = margin_max if margin_max else margin_min
    return min(max_ranges[name] - margin_max * magnitudes[name],
               max(x, min_ranges[name] + margin_min * magnitudes[name]))


min_ranges = {'left_s0': -1.7016, 'left_s1': -2.147, 'left_e0': -3.0541, 'left_e1': -0.05,
              'left_w0': -3.059, 'left_w1': -1.5707, 'left_w2': -3.059,
              'right_s0': -1.7016, 'right_s1': -2.147, 'right_e0': -3.0541, 'right_e1': -0.05,
              'right_w0': -3.059, 'right_w1': -1.5707, 'right_w2': -3.059}

max_ranges = {'left_s0': 1.7016, 'left_s1': 1.047, 'left_e0': 3.0541, 'left_e1': 2.618,
              'left_w0': 3.059, 'left_w1': 2.094, 'left_w2': 3.059,
              'right_s0': 1.7016, 'right_s1': 1.047, 'right_e0': 3.0541, 'right_e1': 2.618,
              'right_w0': 3.059, 'right_w1': 2.094, 'right_w2': 3.059}

magnitudes = {name: max_ranges[name] - min_ranges[name] for name in max_ranges.keys()}

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-j', '--joints', type=str, required=False, nargs='+', default=[], help="joints to be babbled")
    parser.add_argument('-a', '--all', action='store_true', default=False,
                        help="babble all available joints (incompatible with --joints)")
    parser.add_argument('-e', '--excepts', type=str, required=False, nargs='+', default=[],
                        help="exclude joints from babbled one (incompatible with --joints)")
    args = parser.parse_args(rospy.myargv()[1:])

    available_joints = ['head_pan', 'left_s0', 'left_s1', 'left_e0', 'left_e1']
    available_joints_str = ('\n'.join(available_joints)) + '\n'

    if args.all:
        if len(args.joints) > 0:
            rospy.logerr('Inconsistent option : cannot specify both --all and --joints')
        else:
            do_joints = available_joints
        for j in args.excepts:
            if j in available_joints:
                do_joints.remove(j)
            else:
                rospy.logerr('Unkown joint "' + j + '", available_joints:\n' + available_joints_str)
    else:
        if args.joints is []:
            rospy.logerr('You must specify some joints (or -a for all).\nAvailable joint:\n' + available_joints_str)
        else:
            do_joints = []
            for j in args.joints:
                if j in available_joints:
                    do_joints.append(j)
                else:
                    rospy.logerr('Unkown joint "' + j + '", available_joints:\n' + available_joints_str)

    print("Initializing babbler node... ")
    print('Babble joints :', ', '.join(do_joints))
    rospy.init_node("atomic_babbler")
    print("Getting robot state... ")
    rs = baxter_interface.RobotEnable(CHECK_VERSION)
    print("Enabling robot... ")
    rs.enable()
    print("Running. Ctrl-c to quit")

    try:
        main(do_joints)
    except rospy.ROSInterruptException:
        pass
